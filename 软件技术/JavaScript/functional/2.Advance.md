# 函数式编程进阶

## Hindley-Milner 类型系统

什么是类型：

- 函数签名在这个类型系统中可以被认为是“类型到类型的映射”。
- 基于这个逻辑，“类型”在“类型系统”中可以被认为是一个**变量**。TypeScript 基于这个逻辑通过“泛型”设计了一个图灵完全系统。

Parametricity：

- Parametricity 是一种参数多态化函数，统一都满足的抽象性质。它指明了无论多态化参数实例化为那种真实函数，这些函数都有同样的表现形式；
- 比如说有这样的函数签名 `[a] => a`，因为 a 是任意的类型，所以这个函数只能在明确的类型 `Array` 上进行一些操作（比如取它的第一个、最后一个、或随机的一个元素）。

Free Theorem（自由定理，见[论文](https://home.ttic.edu/~dreyer/course/papers/wadler.pdf)）：

- 因为参数多态化函数有上面的 Parametricity 性质，可以推导出函数许多相关的性质。
- 比如下面就是自由定理推导出的一些结果：

```javascript
compose(f, head) === compose(head, map(f));

compose(map(f), filter(compose(p ,f))) === compose(filter(p), map(f));
```

- 这些看起来纯理论毫无价值的公式，实际上是有应用价值的。比如说上面的第一个公式理论上证明它们的计算结果是一样的，但是后者的计算量却比前者要大很多。

Constraints：

- 类型系统可以声明类型映射的参数满足一定的约束。这一理论化的内容在 TypeScript 中是通过 `extends` 关键字实现的。

## 容器

通过一些基础的函数式编程操作，我们得以更优雅地进行编程，但是之前使用的纯函数编程方法却并不能解决所有的问题。比如：控制流、异常处理、异步操作、状态变化等。这些问题都可以用本节抽象的概念解决。

### Container

通过如下方式定义的对象称为一个简单的容器：

```javascript
class Container {
  constructor(x) { this.$value = x; }
  static of (x) { return new this.constructor(x); }
}
```

其中 `static` 函数 `of` 仅仅是为了方便代码更加函数化而定义，不影响理论探究的函数。

具体的，容器的操作应该遵循以下的约定：

1. `Container` 是一个有且仅有一个属性的对象，我们后面将抽象地将它命名为 `$value`；
2. `$value` 不能被约束为任何特定的类型，否则我们的使用场景将相当有限；
3. `$value` 一旦进入容器，它将一只被设置在容器内。我们可以但不应当通过 `.$value` 这种访问属性的方式访问他。

### Functor (Identity)

`Functor` 是一类特殊的 `Container`，我们后续讨论的容器都是基于 `Functor` 的。它的简单实现：

```javascript
class Functor extends Container {  
  map(f) {
    return Functor.of( f(this.$value) );
  }
}
```

所以 `Functor` 是：一种实现了 `map` 方法的容器。

有了 `Functor`，我们就可以像函数式编程一样处理有状态的问题，比如：

```javascript
Functor.of('bombs').map( append(' away') ).map( prop('length') ); // Functor.$value === 10
```

`Functor` 在 `Container` 中就像我们之前在 `compose` 中提到的恒等函数 `id` 一样平凡，所以通常也被称为 `Identity`。

### Maybe

上面的工作是简单平凡的，如果我们在 `Container` 中实现更多的方法，就可以拥有更丰富的功能。

`Maybe` 是一种用 `Functor` 实现空值检测的容器：

```javascript
class Maybe extends Functor {
  get isNothing() {
    return this.$value === null || this.$value === undefined;
  }
  
  map(fn) {
    return this.isNothing ? this : Maybe.of( fn(this.$value) );
  }
  
  inspect() {
    return this.isNothing ? 'Nothing' : `Just(${inspect(this.$value)})`;
  }
}
```

通常情况下，我们强制要求每次调用都需要以 `Maybe` 作为返回值，但是如果我们非要用一个非 `Maybe` 的函数作为返回值，可以借助下面这种方式：

```javascript
//  maybe :: b -> (a -> b) -> Maybe a -> b
var maybe = curry(function(x, f, m) {
  return m.isNothing() ? x : f(m.$value);
});

// 返回值是 string, 而非 Maybe
var getTwenty = compose(
  maybe("You're broke!", finishTransaction), withdraw(20)
);
```

### Either

`Either` 也是一类特殊的 `Functor`，它的本意是指返回值可以是一个 [SumType](https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/sum-types)。

这种 `Fucntor` 可以被用于进行错误处理，不同于 `throw`/`catch`，使用这种方式进行错误处理更加温和，我们可以定义一个左值作为发生异常时的类型（比如一个承载错误信息的字符串，类型为 `String`），右值作为执行成功时的真正结果。

```javascript
class Either extends Functor {
  static of(x) {
    return new Right(x);
  }
}

class Left extends Either {
  map(fn) { return this; }
}

class Right extends Either {
  map(fn) {
    try {
      return Eitherr.of( fn(this.$value) );
    } catch (e) {
      return new Left(e);
    }
  }
}
```

