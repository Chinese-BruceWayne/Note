# 第一部分：数据结构与对象

## 字符串 (Simple Dynamic String)

Redis 没有使用 C 语言中的 `\0` 结尾的方式表示一个字符串，而是自己构建了一个结构 SDS  作为基本字符串类型。这一结构的定义和实现分别在源码的 `src/sds.h`、`src/sds.c` 这两个文件中。

### 结构

以最长 256 字节长度串的结构 `sdshdr8` 为例：

```c
struct __attribute__ ((__packed__)) sdshdr8 {
    uint8_t len; /* used */
    uint8_t alloc; /* excluding the header and null terminator */
    unsigned char flags; /* 3 lsb of type, 5 unused bits */
    char buf[];
};
```

由上面的源码可以看出 SDS 结构的核心是：

1. `len`：已经使用的字符串长度；

2. `alloc`：总共分配的缓冲区长度；

   SDS 为了兼容 C 语言的空字符串结尾，会额外分配一个字节的大小，如果假设字符串可以增加的大小为 `rmd`，那么有公式：`alloc = rmd + len + 1`；

3. `buf`：字符串字面量；

像大多数高级语言一样，使用简单动态字符串这种封装方式有以下好处：

1. 获取字符串长度，时间复杂度 `O(1)`；
2. 二进制安全：杜绝缓冲区溢出、可以存储二进制形式的字符串；
3. 减少修改字符串所需要的内存重新分配次数；
4. 兼容部分 C 字符串函数；

### 方法

`sds` 的创建核心方法可以看到源码中的 `_sdsnewlen`，它的函数签名如下：

```c
sds _sdsnewlen(const void *init, size_t initlen, int trymalloc)
```

在这个函数中可以看到 `sds` 的内存排列方式：

```c
    s = (char*)sh+hdrlen;
    fp = ((unsigned char*)s)-1;
    usable = usable-hdrlen-1;
```

其中 `s` 就是 sds 结构中的 `buf`，并最终赋值给了 `sds` 结构指针；

## 链表 (A Generic Doubly Linked List)

Redis 链表的底层是一个无环双向链表，结构可以在 `src/adlink.h`、`src/adlink.c` 这两个文件中看到。

链表的节点使用结构 `listNode`：

```c
typedef struct listNode {
    struct listNode *prev;
    struct listNode *next;
    void *value;
} listNode;
```

链表本身使用结构 `list`：

```c
typedef struct list {
    listNode *head;
    listNode *tail;
    void *(*dup)(void *ptr);
    void (*free)(void *ptr);
    int (*match)(void *ptr, void *key);
    unsigned long len;
} list;
```

除了 头节点 `head`、尾节点 `tail`、以及链表长度 `len`，结构中另外三个是三个函数：

- `dup` 函数用于复制节点，`free` 函数用于释放节点、`match` 函数用于比较节点；

- 因为 `listNode` 的 `value` 可以指向任意对象，因此需要为 `list` 结构的实例设置三个用于操作节点的函数，这其实是一种多态的体现；

## 字典 (Hash Table)

字典的结构与核心方法可以在 `src/dict.c` 与 `src/dict.h` 这两个文件中看到。

### 结构

实现字典的结构中过程中，涉及了三个核心结构。

字典本身使用 `dict` 这个结构实现的：

```c
typedef struct dict {
    dictType *type;
    void *privdata;
    dictht ht[2];
    long rehashidx; /* rehashing not in progress if rehashidx == -1 */
    int16_t pauserehash; /* If >0 rehashing is paused (<0 indicates coding error) */
} dict;
```

1. 跟 `list` 类似，其中 `dictType` 是一个为了实现多态的函数指针封装；
2. `dictht` 结构才是实现字典的核心结构；
3. `dict` 持有两个 `dictht` 并且定义了 `rehashidx`/`rehashidx` 这些成员变量，是为了 `rehash` 的性能与可用性的考虑；

哈希表使用 `dictht` 实现：

```c
typedef struct dictht {
    dictEntry **table;
    unsigned long size;
    unsigned long sizemask;
    unsigned long used;
} dictht;
```

其中 `dictEntry` 是以链式存储的哈希表节点：

```c
typedef struct dictEntry {
    void *key;
    union {
        void *val;
        uint64_t u64;
        int64_t s64;
        double d;
    } v;
    struct dictEntry *next;
} dictEntry;
```

通过 `next` 字段可以看出 `dictEntry` 的本质是一个链表的节点，哈希表通过这种方式解决哈希冲突；

### 哈希算法

哈希算法是哈希表实现的重点，在代码的注释中可以看到，默认的哈希算法是 `siphash`，该算法在 `siphash.c` 这个文件中实现。

### Rehash 大小

Redis 的哈希表设计巧妙之处正在于 `Rehash` 的方法实现。

调整大小的核心方法是：

```c
int _dictExpand(dict *d, unsigned long size, int* malloc_failed)
```

查看这个方法的实现，可以知道函数通过 `_dictNextPower` 来计算预期的大小。这个方法中会根据 `size` 计算实际预期的大小，这个计算方法是：

```c
static unsigned long _dictNextPower(unsigned long size)
{
    unsigned long i = DICT_HT_INITIAL_SIZE;	// 4
    if (size >= LONG_MAX) return LONG_MAX + 1LU;
    while(1) {
        if (i >= size)
            return i;
        i *= 2;
    }
}
```

查看这个方法的调用，可以得到在什么条件下会触发 Rehash：

```c
/* Expand the hash table if needed */
static int _dictExpandIfNeeded(dict *d) {
  	/// ...
		/* If we reached the 1:1 ratio, and we are allowed to resize the hash
     * table (global setting) or we should avoid it but the ratio between
     * elements/buckets is over the "safe" threshold, we resize doubling
     * the number of buckets. */
    if (d->ht[0].used >= d->ht[0].size &&
        (dict_can_resize ||
         d->ht[0].used/d->ht[0].size > dict_force_resize_ratio) &&
        dictTypeExpandAllowed(d))
    {
        return dictExpand(d, d->ht[0].used + 1);
    }
  	/// ...
}
```

而 `_dictExpandIfNeeded` 则会在每次使用 `_dictKeyIndex` 插入新的 key 时调用。

### Rehash 流程

如果使用普通的 rehash 方案全局调整并且复制，在数据量较大的情况下，会导致服务器短暂的宕机。

因此 Redis 设计了一个渐进式的 Rehash 方式，渐进式地多次完成，而不是集中地一次完成。具体的，在 Rehash 的过程中 ，`dict` 会存储两份 `dictht` 数据，所有的增删改查操作都会在这两个表中进行。

Rehash 的原子步骤是源码中的 `dictRehash` 这个方法，它的签名和注释如下：

```c
/* Performs N steps of incremental rehashing. Returns 1 if there are still
 * keys to move from the old to the new hash table, otherwise 0 is returned.
 *
 * Note that a rehashing step consists in moving a bucket (that may have more
 * than one key as we use chaining) from the old to the new hash table, however
 * since part of the hash table may be composed of empty spaces, it is not
 * guaranteed that this function will rehash even a single bucket, since it
 * will visit at max N*10 empty buckets in total, otherwise the amount of
 * work it does would be unbound and the function may block for a long time. */
int dictRehash(dict *d, int n)
```

在这个方法中，以 `rehashidx` 为标记，把之后连续的 `n` 个记录从 `ht[0]` 迁移到 `ht[1]`。每当一个元素从 `ht[0]` 迁移到 `ht[1]`，函数会更改 `used` 字段同时维持 `size` 字段不变，`ht[0]` 中对应下标位置的指针将会被指向为 `NULL`。

查看这个函数的调用栈可以分析 Redis 具体是如何执行 Rehash 操作的。

1. `dictRehashMilliseconds`：函数接收一个以 `ms` 为单位的时间参数，函数内部每次 “迁移 100 个元素”为原子操作，进行执行时间不超过这个上限的 rehash。

   在 `server.c` 文件中通过调用这个函数进行 rehash 操作，每 `100ms` 会占用小于 `1ms` 时间进行 rehash。

```c
/* Rehash in ms+"delta" milliseconds. The value of "delta" is larger 
 * than 0, and is smaller than 1 in most cases. The exact upper bound 
 * depends on the running time of dictRehash(d,100).*/
int dictRehashMilliseconds(dict *d, int ms) {
    if (d->pauserehash > 0) return 0;
    long long start = timeInMilliseconds();
    int rehashes = 0;
    while(dictRehash(d,100)) {
        rehashes += 100;
        if (timeInMilliseconds()-start > ms) break;
    }
    return rehashes;
}
```

2. `_dictRehashStep`：对单步迁移操作的封装。

   该函数在添加删除查找等方法被执行时会用到，我感觉这么做的好处是可以将计算压力分摊到每次访问请求中，而基本不会影响每次访问的查询速度。同时间接地实现了“越被频繁使用的字典，计算优先级越高”；

`PS`：美团技术团队针对 Redis-Rehash 这一方向进行了优化：https://tech.meituan.com/2018/07/27/redis-rehash-practice-optimization.html

## 跳跃表 (Skip List)

> 关于跳跃表详细原理见论文：
>
> - 《Skip Lists: A Probabilistic Alternative to Balnced Trees》

跳跃表定义在 `server.h` 这个文件中，它是有序集合的底层实现之一。

跳跃表本身的实现结构名称为 `zskiplist`：

```c
typedef struct zskiplist {
    struct zskiplistNode *header, *tail;
    unsigned long length;
    int level;
} zskiplist;
```

其中 `zskiplistNode` 主要由 字符值、分值、多层跳跃指针 三个部分构成：

```c
typedef struct zskiplistNode {
    sds ele;
    double score;
    struct zskiplistNode *backward;
    struct zskiplistLevel {
        struct zskiplistNode *forward;
        unsigned long span;
    } level[];
} zskiplistNode;
```

完美的跳跃表可以实现 `O(log n)` 的查找时间复杂度。

## 整数集合（Integer Set）

整数集合定义在 `intset.c` 与 `inset.h` 这两个文件中，它是集合键的底层实现之一。

### 结构

`intset` 的结构定义相当简单：

```c
typedef struct intset {
    uint32_t encoding;
    uint32_t length;
    int8_t contents[];
} intset;
```

其中 `encoding` 可以认为是高级语言中的枚举值，它定义在 `intset.c` 文件中：

```c
#define INTSET_ENC_INT16 (sizeof(int16_t))
#define INTSET_ENC_INT32 (sizeof(int32_t))
#define INTSET_ENC_INT64 (sizeof(int64_t))
```

`contents` 实际存储的数据类型由这个 `encoding` 决定，它会在访问时进行强制类型转化。