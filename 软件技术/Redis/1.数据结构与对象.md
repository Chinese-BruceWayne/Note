# 第一部分：数据结构与对象

> 因为阅读的书已经较为过时，新的数据结构没有完全讲完，比如：
>
> - `zipmap`、`quicklist`、`steam`

## 字符串 (Simple Dynamic String)

Redis 没有使用 C 语言中的 `\0` 结尾的方式表示一个字符串，而是自己构建了一个结构 SDS  作为基本字符串类型。这一结构的定义和实现分别在源码的 `src/sds.h`、`src/sds.c` 这两个文件中。

### 结构

以最长 256 字节长度串的结构 `sdshdr8` 为例：

```c
struct __attribute__ ((__packed__)) sdshdr8 {
    uint8_t len; /* used */
    uint8_t alloc; /* excluding the header and null terminator */
    unsigned char flags; /* 3 lsb of type, 5 unused bits */
    char buf[];
};
```

由上面的源码可以看出 SDS 结构的核心是：

1. `len`：已经使用的字符串长度；

2. `alloc`：总共分配的缓冲区长度；

   SDS 为了兼容 C 语言的空字符串结尾，会额外分配一个字节的大小，如果假设字符串可以增加的大小为 `rmd`，那么有公式：`alloc = rmd + len + 1`；

3. `buf`：字符串字面量；

像大多数高级语言一样，使用简单动态字符串这种封装方式有以下好处：

1. 获取字符串长度，时间复杂度 `O(1)`；
2. 二进制安全：杜绝缓冲区溢出、可以存储二进制形式的字符串；
3. 减少修改字符串所需要的内存重新分配次数；
4. 兼容部分 C 字符串函数；

### 方法

`sds` 的创建核心方法可以看到源码中的 `_sdsnewlen`，它的函数签名如下：

```c
sds _sdsnewlen(const void *init, size_t initlen, int trymalloc)
```

在这个函数中可以看到 `sds` 的内存排列方式：

```c
    s = (char*)sh+hdrlen;
    fp = ((unsigned char*)s)-1;
    usable = usable-hdrlen-1;
```

其中 `s` 就是 sds 结构中的 `buf`，并最终赋值给了 `sds` 结构指针；

## 链表 (A Generic Doubly Linked List)

Redis 链表的底层是一个无环双向链表，结构可以在 `src/adlink.h`、`src/adlink.c` 这两个文件中看到。

链表的节点使用结构 `listNode`：

```c
typedef struct listNode {
    struct listNode *prev;
    struct listNode *next;
    void *value;
} listNode;
```

链表本身使用结构 `list`：

```c
typedef struct list {
    listNode *head;
    listNode *tail;
    void *(*dup)(void *ptr);
    void (*free)(void *ptr);
    int (*match)(void *ptr, void *key);
    unsigned long len;
} list;
```

除了 头节点 `head`、尾节点 `tail`、以及链表长度 `len`，结构中另外三个是三个函数：

- `dup` 函数用于复制节点，`free` 函数用于释放节点、`match` 函数用于比较节点；

- 因为 `listNode` 的 `value` 可以指向任意对象，因此需要为 `list` 结构的实例设置三个用于操作节点的函数，这其实是一种多态的体现；

## 字典 (Hash Table)

字典的结构与核心方法可以在 `src/dict.c` 与 `src/dict.h` 这两个文件中看到。

### 结构

实现字典的结构中过程中，涉及了三个核心结构。

字典本身使用 `dict` 这个结构实现的：

```c
typedef struct dict {
    dictType *type;
    void *privdata;
    dictht ht[2];
    long rehashidx; /* rehashing not in progress if rehashidx == -1 */
    int16_t pauserehash; /* If >0 rehashing is paused (<0 indicates coding error) */
} dict;
```

1. 跟 `list` 类似，其中 `dictType` 是一个为了实现多态的函数指针封装；
2. `dictht` 结构才是实现字典的核心结构；
3. `dict` 持有两个 `dictht` 并且定义了 `rehashidx`/`rehashidx` 这些成员变量，是为了 `rehash` 的性能与可用性的考虑；

哈希表使用 `dictht` 实现：

```c
typedef struct dictht {
    dictEntry **table;
    unsigned long size;
    unsigned long sizemask;
    unsigned long used;
} dictht;
```

其中 `dictEntry` 是以链式存储的哈希表节点：

```c
typedef struct dictEntry {
    void *key;
    union {
        void *val;
        uint64_t u64;
        int64_t s64;
        double d;
    } v;
    struct dictEntry *next;
} dictEntry;
```

通过 `next` 字段可以看出 `dictEntry` 的本质是一个链表的节点，哈希表通过这种方式解决哈希冲突；

### 哈希算法

哈希算法是哈希表实现的重点，在代码的注释中可以看到，默认的哈希算法是 `siphash`，该算法在 `siphash.c` 这个文件中实现。

### Rehash 大小

Redis 的哈希表设计巧妙之处正在于 `Rehash` 的方法实现。

调整大小的核心方法是：

```c
int _dictExpand(dict *d, unsigned long size, int* malloc_failed)
```

查看这个方法的实现，可以知道函数通过 `_dictNextPower` 来计算预期的大小。这个方法中会根据 `size` 计算实际预期的大小，这个计算方法是：

```c
static unsigned long _dictNextPower(unsigned long size)
{
    unsigned long i = DICT_HT_INITIAL_SIZE;	// 4
    if (size >= LONG_MAX) return LONG_MAX + 1LU;
    while(1) {
        if (i >= size)
            return i;
        i *= 2;
    }
}
```

查看这个方法的调用，可以得到在什么条件下会触发 Rehash：

```c
/* Expand the hash table if needed */
static int _dictExpandIfNeeded(dict *d) {
  	/// ...
		/* If we reached the 1:1 ratio, and we are allowed to resize the hash
     * table (global setting) or we should avoid it but the ratio between
     * elements/buckets is over the "safe" threshold, we resize doubling
     * the number of buckets. */
    if (d->ht[0].used >= d->ht[0].size &&
        (dict_can_resize ||
         d->ht[0].used/d->ht[0].size > dict_force_resize_ratio) &&
        dictTypeExpandAllowed(d))
    {
        return dictExpand(d, d->ht[0].used + 1);
    }
  	/// ...
}
```

而 `_dictExpandIfNeeded` 则会在每次使用 `_dictKeyIndex` 插入新的 key 时调用。

### Rehash 流程

如果使用普通的 rehash 方案全局调整并且复制，在数据量较大的情况下，会导致服务器短暂的宕机。

因此 Redis 设计了一个渐进式的 Rehash 方式，渐进式地多次完成，而不是集中地一次完成。具体的，在 Rehash 的过程中 ，`dict` 会存储两份 `dictht` 数据，所有的增删改查操作都会在这两个表中进行。

Rehash 的原子步骤是源码中的 `dictRehash` 这个方法，它的签名和注释如下：

```c
/* Performs N steps of incremental rehashing. Returns 1 if there are still
 * keys to move from the old to the new hash table, otherwise 0 is returned.
 *
 * Note that a rehashing step consists in moving a bucket (that may have more
 * than one key as we use chaining) from the old to the new hash table, however
 * since part of the hash table may be composed of empty spaces, it is not
 * guaranteed that this function will rehash even a single bucket, since it
 * will visit at max N*10 empty buckets in total, otherwise the amount of
 * work it does would be unbound and the function may block for a long time. */
int dictRehash(dict *d, int n)
```

在这个方法中，以 `rehashidx` 为标记，把之后连续的 `n` 个记录从 `ht[0]` 迁移到 `ht[1]`。每当一个元素从 `ht[0]` 迁移到 `ht[1]`，函数会更改 `used` 字段同时维持 `size` 字段不变，`ht[0]` 中对应下标位置的指针将会被指向为 `NULL`。

查看这个函数的调用栈可以分析 Redis 具体是如何执行 Rehash 操作的。

1. `dictRehashMilliseconds`：函数接收一个以 `ms` 为单位的时间参数，函数内部每次 “迁移 100 个元素”为原子操作，进行执行时间不超过这个上限的 rehash。

   在 `server.c` 文件中通过调用这个函数进行 rehash 操作，每 `100ms` 会占用小于 `1ms` 时间进行 rehash。

```c
/* Rehash in ms+"delta" milliseconds. The value of "delta" is larger 
 * than 0, and is smaller than 1 in most cases. The exact upper bound 
 * depends on the running time of dictRehash(d,100).*/
int dictRehashMilliseconds(dict *d, int ms) {
    if (d->pauserehash > 0) return 0;
    long long start = timeInMilliseconds();
    int rehashes = 0;
    while(dictRehash(d,100)) {
        rehashes += 100;
        if (timeInMilliseconds()-start > ms) break;
    }
    return rehashes;
}
```

2. `_dictRehashStep`：对单步迁移操作的封装。

   该函数在添加删除查找等方法被执行时会用到，我感觉这么做的好处是可以将计算压力分摊到每次访问请求中，而基本不会影响每次访问的查询速度。同时间接地实现了“越被频繁使用的字典，计算优先级越高”；

`PS`：美团技术团队针对 Redis-Rehash 这一方向进行了优化：https://tech.meituan.com/2018/07/27/redis-rehash-practice-optimization.html

## 跳跃表 (Skip List)

> 关于跳跃表详细原理见论文：
>
> - 《Skip Lists: A Probabilistic Alternative to Balnced Trees》

跳跃表定义在 `server.h` 这个文件中，它是有序集合的底层实现之一。

跳跃表本身的实现结构名称为 `zskiplist`：

```c
typedef struct zskiplist {
    struct zskiplistNode *header, *tail;
    unsigned long length;
    int level;
} zskiplist;
```

其中 `zskiplistNode` 主要由 字符值、分值、多层跳跃指针 三个部分构成：

```c
typedef struct zskiplistNode {
    sds ele;
    double score;
    struct zskiplistNode *backward;
    struct zskiplistLevel {
        struct zskiplistNode *forward;
        unsigned long span;
    } level[];
} zskiplistNode;
```

完美的跳跃表可以实现 `O(log n)` 的查找时间复杂度。

## 整数集合（Integer Set）

整数集合定义在 `intset.c` 与 `inset.h` 这两个文件中，它是用于保存整数值的集合抽象数据结构：即它保存内容为整数值，并且集合内不会出现重复元素。它是集合键的底层实现之一。

### 结构

`intset` 的结构定义相当简单：

```c
typedef struct intset {
    uint32_t encoding;
    uint32_t length;
    int8_t contents[];
} intset;
```

其中 `encoding` 可以认为是高级语言中的枚举值，它定义在 `intset.c` 文件中：

```c
#define INTSET_ENC_INT16 (sizeof(int16_t))
#define INTSET_ENC_INT32 (sizeof(int32_t))
#define INTSET_ENC_INT64 (sizeof(int64_t))
```

`contents` 实际存储的数据类型由这个 `encoding` 决定，它会在访问时进行强制类型转化。

### 升级

通过不同的 encoding 存储有以下好处：

1. 提升灵活性，因为 C 语言的特性，不能用一个结构同时存储多个类型的数据；
2. 节约内存，不需要为了大量小数字开辟大量高位内存；

但是因为 inset 的内容会动态变化，在一些场景下会触发升级（encoding 从小的类型转变为大的类型）。

升级：`intsetUpgradeAndAdd`，在插入一个比类型值还大的数字时会触发升级。函数签名：

```c
/* Upgrades the intset to a larger encoding and inserts the given integer. */
static intset *intsetUpgradeAndAdd(intset *is, int64_t value)
```

*PS*：为什么 inset 不像 hashtable 设计一个渐进性的升级方案。

## 压缩列表（Zip List）

压缩列表是为了节约内存而诞生的一种数据结构，它的本质是一个通过特殊编码方式存储的双向链表。

当一个列表值中只包含少量的列表项，并且每个列表项要么就是小的整数值，要么就是比较短的字符串。那么Redis 底层就是使用压缩列表来做列表键的底层实现。

### 结构

压缩列表的详细数据结构在源代码的 `ziplist.c` 文件开头有长达 200 行的注释解释，大体概括就是下面的结构：

```c
<zlbytes> <zltail> <zllen> <entry> <entry> ... <entry> <zlend>
```

其中：

- `zlbytes` 指明了包括它自己在内的整个 `ziplist` 字节大小；
- `zltail` 指明了最后一个 entry 的相对偏移；
- `zllen` 指明了数组长度大小，即之后跟的 `entry` 的数量；
- `zlend` 是一个表征压缩列表结尾的字节，固定的值 `0xFF`；

`entry` 的内部也有许多通过编码降低内存的设计，大体概述就是下面的结构：

```c
<prevlen> <encoding> <entry-data>
```

在不同的情况下，这一基本结构有不同的变体。

比如对于小整数，encoding，自身就可以表示数值，此时的结构为：

```c
<prevlen> <encoding>
```

`prevlen` 通常只用一个字节表示，如果长度大于等于 254，则第一个字节置位为 `0xFE`：

```c
0xFE <4 bytes unsigned little endian prevlen> <encoding> <entry>
```

### 操作

压缩列表是一个“时间换空间”的设计，所以只能用于小列表项。

- 下标访问、entry 前指、entry 后指、获取字节数、获取列表大小等查询操作都是 `O(1)`；
- 插入、删除等涉及到大小变化的更新操作时间复杂度都是平均 `O(N)`；

- 插入、删除可能会引发连锁更新，所以最坏的时间复杂度是 `O(N^2)`

什么是连锁更新？

- 当 `ziplist` 保存了大量长度为 253 长度的 entry 时，如果在第一个位置插入了一个长度大于 253 的元素，则会导致之后的每一个 entry 执行连锁更新，时间复杂度 `O(N^2)`

## 对象

Redis 暴露给用户的并不是上面列举的这些“基本数据结构”，而是五个对象：

- 字符串对象（无前缀）、列表对象 (l)、哈希对象 (h)、集合对象 (s)、有序集合对象 (z)；

Redis 通过不同的编码方式表征具体的底层实现。

### 结构

redisObject 声明在文件 `rio.h` 中，实际定义在 `server.c` 中：

```c
typedef struct redisObject {
    unsigned type:4;
    unsigned encoding:4;
    unsigned lru:LRU_BITS; /* LRU time (relative to global lru_clock) or
                            * LFU data (least significant 8 bits frequency
                            * and most significant 16 bits access time). */
    int refcount;
    void *ptr;
} robj;
```

其中 `type` 就是在前面列举的五个基本数据类型：

```c
/* The actual Redis Object */
#define OBJ_STRING 0    /* String object. */
#define OBJ_LIST 1      /* List object. */
#define OBJ_SET 2       /* Set object. */
#define OBJ_ZSET 3      /* Sorted set object. */
#define OBJ_HASH 4      /* Hash object. */
```

### 编码

`encoding` 表征这这个类型的对象底层使用的数据结构，通常一个类型只会使用两个底层数据结构：

```c
/* Objects encoding. Some kind of objects like Strings and Hashes can be
 * internally represented in multiple ways. The 'encoding' field of the object
 * is set to one of this fields for this object. */
#define OBJ_ENCODING_RAW 0     /* Raw representation */
#define OBJ_ENCODING_INT 1     /* Encoded as integer */
#define OBJ_ENCODING_HT 2      /* Encoded as hash table */
#define OBJ_ENCODING_ZIPMAP 3  /* Encoded as zipmap */
#define OBJ_ENCODING_LINKEDLIST 4 /* No longer used: old list encoding. */
#define OBJ_ENCODING_ZIPLIST 5 /* Encoded as ziplist */
#define OBJ_ENCODING_INTSET 6  /* Encoded as intset */
#define OBJ_ENCODING_SKIPLIST 7  /* Encoded as skiplist */
#define OBJ_ENCODING_EMBSTR 8  /* Embedded sds string encoding */
#define OBJ_ENCODING_QUICKLIST 9 /* Encoded as linked list of ziplists */
#define OBJ_ENCODING_STREAM 10 /* Encoded as a radix tree of listpacks */
```

具体到五个对象：

1. 字符串对象：`int`、`raw`、`embstr`；
2. 列表对象：`ziplist`、`linkedlist`；
3. 哈希对象：`ziplist`、`hashtable`；
4. 集合对象：`intset`、`hashtable`；
5. 有序集合对象：`ziplist`、`skiplist`；

