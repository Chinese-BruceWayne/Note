# ROP 技术

## 基本 ROP

### ret2text

ret2text 即控制程序执行程序本身已有的的代码 (.text)。[例子](https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2text/bamboofox-ret2text/ret2text)

### ret2shellcode

ret2shellcode，即控制程序执行 shellcode 代码。**一般来说，shellcode 需要我们自己填充**。[例子](https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2shellcode/ret2shellcode-example/ret2shellcode)

### ret2syscall

ret2syscall，即控制程序执行系统调用，获取 shell。[例子](https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2syscall/bamboofox-ret2syscall/rop)

此时就需要用到 ROP 链了，得到 ROP 链可以使用 `ROPgadget` 这个工具，见 [TIPS](../../题目/TIPS.md)

### ret2libc

ret2libc 即控制函数的执行 `libc` 中的函数，通常是返回至某个函数的 `plt` 处或者函数的具体位置 (即函数对应的 `got` 表项的内容)。

一般情况下，我们会选择执行 `system("/bin/sh")`，故而此时我们需要知道 `system` 函数的地址。

## 中级 ROP

### ret2csu

在 64 位程序中，函数的前 6 个参数是通过寄存器传递的，但是大多数时候，我们很难找到每一个寄存器对应的 `gadgets`。 这时候，我们可以利用 `x64` 下的 `__libc_csu_init` 中的 `gadgets`。

这个函数是用来对 libc 进行初始化操作的，而一般的程序都会调用 libc 函数，所以这个函数一定会存在。

### BROP

黑盒测试的办法。见：<http://www.scs.stanford.edu/brop/bittau-brop.pdf>

## 高级 ROP

### ret2dlresolve

要想弄懂这个 ROP 利用技巧，需要首先理解 ELF 文件的基本结构以及动态链接的基本过程：

