# 静态分析

iOS 的静态分析工具主要有 Hopper/IDA Pro。

## Hopper

## IDA Pro

下面是一些 IDA Pro 的常用功能与快捷键：

1. 字符串搜索：Alt+T (Windows)；Option+T (Mac OS)；
2. 跳转地址：在 IDA 中按 "G"，输入指定的跳转地址即可跳转；
3. 编写注释：
   1. 可重复注释：按 ";" 分号，可以添加可重复注释，这种注释会同时出现在其交叉引用的地方；
   2. 非重复注释：按 ":" 冒号，可添加重复注释，优先级大于前者，不过不会出现在交叉引用的位置；
   3. 伪代码注释：直接按 "/" 分号，可以为伪代码添加注释；
4. 变量重命名：单击目标变量，按 "N" 进行重命名；
5. 查看交叉引用：选中函数/变量，按 "X" 可以查看当前位置被哪些地方引用了；
6. 进制转换：伪代码展示的数字默认进制是十进制，可以按 "H" 进行进制转换；
7. 类型声明：变量类型/方法参数签名等，如果 IDA 默认识别有问题，可以按 "Y" 进行重声明；
8. 格式转化：
   1. 在被解析为数据的位置按 "C" 可以解析为代码，反之按 "D"；
   2. 对于一连串的 ASCII 字符，按 "A" 可以将一连串地址的字符转化为字符串；
   3. 按 "U" 可以取消对数据段的解析；

## 静态分析实践

### 产物分析

我们使用 XCode 默认建立的工程，在 viewDidLoad 里面编写了一段代码，看看这写代码是如何实现的：

```objective-c
#define SCREEN_WIDTH [UIScreen mainScreen].bounds.size.width
#define SCREEN_HEIGHT [UIScreen mainScreen].bounds.size.height
#define TEXT_WIDTH 100
#define TEXT_HEIGHT 100

@implementation ViewController

- (void)viewDidLoad
{
    CGPoint origin = CGPointMake((SCREEN_WIDTH - TEXT_WIDTH) / 2, (SCREEN_HEIGHT - TEXT_HEIGHT) / 2);
    UITextView *customTextView = [[UITextView alloc] initWithFrame:CGRectMake(origin.x,
                                                                        origin.y,
                                                                        TEXT_WIDTH,
                                                                        TEXT_HEIGHT)];
    customTextView.text = @"Westworld.";
    customTextView.scrollEnabled = YES;
    customTextView.editable = NO;
    [self.view addSubview:customTextView];
}

@end
```

在 Product 文件夹中，找到 `.app` 后缀的产物文件夹，放入 IDA。在左侧窗口注意到这个方法：`- [ViewController viewDidLoad]`：

```c
void __cdecl -[ViewController viewDidLoad](ViewController *self, SEL a2)
{
  void *v2; // rax
  void *v3; // r15
  void *v4; // rax
  void *v5; // rbx

  v2 = (void *)objc_alloc((__int64)&OBJC_CLASS___UITextView, (__int64)a2);
  v3 = objc_msgSend(v2, "initWithFrame:", xmmword_100002460, xmmword_100002470);
  objc_msgSend(v3, "setText:", CFSTR("Westworld."), xmmword_100002460, xmmword_100002470);
  v4 = objc_msgSend(self, "view");
  v5 = (void *)objc_retainAutoreleasedReturnValue((__int64)v4);
  objc_msgSend(v5, "addSubview:", v3);
  objc_release(v5);
  objc_release(v3);
}
```

上面的伪代码结果可以让我们对 OC 的局部变量的工作机制有一定的了解，有关 `objc_alloc` / `objc_msgSend` 等函数的实现，我们使用现在的 `.app` 产物文件包，暂时是看不到的。

### 包大小优化案例

一个经典的包大小优化方式是 Block 优化，为什么对 Block 的优化可以优化包大小呢？

我编写了下面一个测试程序：

```objective-c
- (void)normalSet
{
    [self.testWithMap setMapMsgWithBlock:^(NSMutableDictionary * _Nonnull map) {
        map[@"hello1"] = @"hello1";
        map[@"hello2"] = @"hello2";
        map[@"hello3"] = @"hello3";
        map[@"hello4"] = @"hello4";
    }];
}

- (void)optimizeSet
{
    NSMutableDictionary *map = self.testWithMap.testMap;
    map[@"hello1"] = @"hello1";
    map[@"hello2"] = @"hello2";
    map[@"hello3"] = @"hello3";
    map[@"hello4"] = @"hello4";
}
```

在 IDA Pro 中分析后可以得到使用两种方法对内存的增量改变：

![BlockAnalysis_TextSegmentSize](./BlockAnalysis_TextSegmentSize.png)

除此之外，前者还在数据端保存了一份 block 的结构体：

```c
struct __block_impl {
  void *isa; 
  int Flags; 
  int Reserved; 
  void *FuncPtr;
};
```

![image-20201029214818695](/Users/shesonglin/Program/Note/安全技术/iOS逆向分析/BlockAnalysis_DataSegmentSize.png)

用更直观的图表示：

![BlockAnalysis_Reason](./BlockAnalysis_Reason.svg)

这也就是说：

- `normalSet` 方法占用字节大小：`0x60 + 0xC8 + 0x18 = 0x140`
- `optimizeSet` 方法占用的字节大小：`0xF8`

