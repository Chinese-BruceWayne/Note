> 参考资料：
>
> - 64 位程序函数调用的参数传递顺序：<http://abcdxyzk.github.io/blog/2012/11/23/assembly-args/>
> - 通过签名文件，还原静态链接函数名：<https://github.com/maroueneboubakri/lscan/wiki/Reverse-Engineer-a-stripped-binary-with-lscan-and-IDApro>

# 3x17

## 保护等级

首先检查程序的保护等级：

```bash
$ checksec 3x17 
[*] '/media/data/program/ctf/pwnable/3x17/3x17'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
```

首先我们发现这是一个 64 位的程序，另外程序没有开启栈溢出的 `canary` 保护，但是堆栈不可执行。

我们再看程序的链接方式：

```bash
$ objdump -R 3x17 

3x17：     文件格式 elf64-x86-64

objdump: 3x17：不是动态对象
objdump: 3x17: invalid operation
```

是一个静态链接的文件。

## 加载 `sig` 函数签名

### `lscan.py`

在 `gdb` 中我们并没有发现任何函数名与变量名的信息。于是我们可以尝试为文件添加一些标识，否则分析起来就太困难了。

我在网上找了一圈，发现大家都用一个 `lscan.py` 的项目，这是一个启发式的检测项目，这个项目通过识别文件的签名，为静态链接的文件查找最可能用于链接的签名文件：

```bash
$ mkvirtualenv -p python2.7 Reverse2.7

$ pip install pyelftools pefile

$ git clone https://github.com/maroueneboubakri/lscan.git && cd lscan

$ python lscan.py -f D:/program/ctf/pwnable/3x17/3x17 -S ./amd64/sig
D:\program\git\lscan\amd64\sig\libc-2.13.sig 12266/3369 (364.08%)
D:\program\git\lscan\amd64\sig\libc-2.22.sig 12870/2859 (450.16%)
D:\program\git\lscan\amd64\sig\libc-2.23.sig 13163/2869 (458.80%)
D:\program\git\lscan\amd64\sig\libcrypto-1.0.2h.sig 36850/5057 (728.69%)
D:\program\git\lscan\amd64\sig\libm-2.13.sig 11125/445 (2500.00%)
D:\program\git\lscan\amd64\sig\libm-2.22.sig 11121/582 (1910.82%)
D:\program\git\lscan\amd64\sig\libm-2.23.sig 11124/600 (1854.00%)
D:\program\git\lscan\amd64\sig\libpcre-8.38.sig 18/150 (12.00%)
D:\program\git\lscan\amd64\sig\libpthread-2.13.sig 11379/319 (3567.08%)
D:\program\git\lscan\amd64\sig\libpthread-2.22.sig 11159/262 (4259.16%)
D:\program\git\lscan\amd64\sig\libpthread-2.23.sig 11160/258 (4325.58%)
D:\program\git\lscan\amd64\sig\libssl-1.0.2h.sig 0/665 (0.00%)
```

我们发现它们的识别率都超过的 `100%`，而项目官网上提供的 demo 中是很正确的，那一定是哪里出了问题，于是我开始阅读这个工具的源码以修正这一 `bug`。

### 项目修复

我们首先使用 `pycallgraph` 这个工具得到了一个函数的调用图：

![./3x17-lscan-cfg.png](./3x17-lscan-cfg.png)

可见 `lscan` 的大致流程大概分为三步：解析 `elf` 可执行文件、解析 `sig` 签名文件、匹配 `sig` 与 `elf`。根据上面出现的问题，应该是第三步解析错误。