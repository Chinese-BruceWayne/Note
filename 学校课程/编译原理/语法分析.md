> 学习地址：
>
> [国防科技大学MOOC]()

# 语法分析

## 简述概念

上下文无关文法：

- 定义：一个上下文无关文法 G 是一个四元式 $$G= (V_T, V_N, S, P)$$，其中：
  - $$V_T$$：终结符号集合（非空）；
  - $$V_N$$：非终结符集合（非空），且 $$V_T \cap V_N = \varnothing$$
  - $$S$$：文法的开始符号，$$S \in V_N$$
  - $$P$$：产生式集合（有限），每个产生式形式为：
    - $$P \rightarrow \alpha, P \in V_N, \alpha \in (V_T \cup V_N)*$$

直接推出：

- 定义：称 $$\alpha A \beta$$ 直接推出 $$\alpha \gamma \beta$$，即：$$\alpha A \beta \Rightarrow \alpha \gamma \beta$$。仅当 $$A \rightarrow \gamma $$ 是一个产生式，且 $$\alpha, \beta \in (V_T \cup V_N)*$$

推导：

- 如果 $$\alpha_1 \Rightarrow \alpha_2 \Rightarrow ... \Rightarrow \alpha_n$$，则我们称这个序列是从 $$\alpha_1$$ 到 $$\alpha_n$$ 的一个推导。若存在一个从 $$\alpha_1$$ 到 $$\alpha_n$$ 的推导，则称 $$\alpha_1$$ 可以推导出 $$\alpha_n$$。

句型：

- 定义：假定 G 是一个文法，S 是它的开始符号。如果 $$S \Rightarrow \alpha$$，则 $$\alpha$$ 称时一个句型。
- 由文法的开始符号能够推导出的任意串，都是该文法的一个句型。

句子：仅含终结符号的句型。

语言：

- 文法所产生的句子的全体是一个语言，将它记作 $$L(G)$$。
  - $$L(G) = \{\alpha | S \Rightarrow \alpha, \alpha \in V_T^*\}$$



语法分析任务：分析一个文法的句子的结构

语法分析器的功能：按照文法的产生式（语言的语法规则），识别输入符号串是否为一个句子（合式程序）

## 自上而下分析 Top-down

从文法的开始符号开始，反复使用各种产生式，寻找 “匹配” 的推导。

- 推导：根据文法的产生式规则，把串中出现的产生式的左部符号替换成右部

从树的根节点开始，构造语法树。

算法：递归下降法，预测分析程序。

### 基本问题

面临的两个基本问题

- 当面临多个候选式时的**回溯**问题。
- 文法的**左递归**问题。

#### 左递归的消除

一个文法消除左递归的条件：

- 不含以 $$\epsilon$$ 为右部的左产生式
- 不含回路，即不含推导 $$P \Rightarrow P$$

**直接左递归**的消除：

- 产生式的直接左递归：$$P \rightarrow P\alpha | \beta, \beta 不以 \beta 开头$$
- 转变成右递归文法：
  - $$P \rightarrow \beta P'$$
  - $$P' \rightarrow \alpha P' | \epsilon$$

- 推广：$$P \rightarrow P\alpha_1 | P\alpha_2 | ...| P\alpha_m| \beta_1 | \beta_2 | ... | \beta_n$$（每个 $$\alpha$$ 都不等于 $$\epsilon$$，每个 $$\beta$$ 都不以 P 开头）
  - $$P \rightarrow \beta_1 P' | \beta_2 P‘ |...|\beta_n P'$$
  - $$P' \rightarrow P' \alpha_1 | P' \alpha_2 | ... | P' \alpha_m$$

**间接左递归**的消除：

- 算法：
  1. 把文法 G 中的所有非终结符按任意一种顺序排列 $$P_1, P_2, ..., P_n$$；按此顺序执行：
  2. 把 $$P_i$$ 的规则改造 成  $$P_i \rightarrow a...|P_{i+1}...|P_{i+2}...|...|P_{i+k}...$$，即 $$P_i$$ 的推导式，只能以下标大于 $$i$$ 的开头。并消除 $$P_i$$ 的直接左递归。
  3. 化简 2 所得到的文法，去除从开始符号出发无法到达的非终结符的产生规则。

#### 回溯的消除

回溯消除的结果：

- 对于文法的任何非终结符，当他要去匹配输入串时，能够根据它所面临的输入符号准确地指派它的一个候选去执行任务，并且此候选的工作结果应该是确信无疑的。

引入概念：

- FIRST 集合：
  - 令 G 是一个不含左递归的文法，对于 G 中的每个非终结符 $$\alpha$$ 定义它的终结首符号集 $$FIRST(\alpha)$$ 为：
    - $$FISRT(\alpha) = \{a | \alpha \Rightarrow a..., a \in V_T\}$$
    - 特别的，若 $$\alpha \Rightarrow \epsilon$$，则规定 $$\epsilon \in FIRST(\alpha)$$
  - 则：没有回溯 $$\Leftrightarrow$$ $$ A \rightarrow \alpha_i|\alpha_j, FIRST(\alpha_i) \cap FIRST(\alpha_j) = \varnothing $$

- FOLLOW 集合：
  - 假定 S 是文法的开始符号，对于 G 的任何非终结符 A，我们定义 A 的 FOLLOW 集合：
    - $$FOLLOW(A) = \{a | S \Rightarrow ...Aa...., a \in V_T\}$$
    - 特别的，若 $$S \Rightarrow ...A$$，则规定 $$ \$ \in FOLLOW(A) $$

算法：

- 提取左公共因子：
  - 假定 A 的规则是：$$A \rightarrow \delta \beta_1 | \delta \beta_2 | ... | \delta \beta_n | \gamma_1 | \gamma_2 | ... | \gamma_m$$（其中每个 $$\gamma$$ 都不以 $$\delta$$ 开头）
  - 那么可以将这些规则改写成：
    - $$A \rightarrow \delta A' | \gamma_1 | \gamma_2 | ... | \gamma_m $$
    - $$A' \rightarrow \beta_1 | \beta_2 | ... | \beta_n$$

### LL(1) 文法

一个文法 G 满足下面条件，称作该文法 G 为 LL(1) 文法。

1. 文法不含左递归
2. 对于文法中每一个非终结符 A 的各个产生式的候选首符集两两不相交。
   - 即：$$ A \rightarrow \alpha_i|\alpha_j, FIRST(\alpha_i) \cap FIRST(\alpha_j) = \varnothing $$
3. 对文法中的每一个非终结符，若存在某个候选首符集包含 $$\epsilon$$，则：$$FIRST(\alpha_i) \cup FOLLOW(A) = \varnothing, i=1,2,...,n$$

其中第一个 L 表示从左到右扫描输入串，第二个 L 表示分析过程是一个最左推导，1 表示每次只需前进一个符号。

#### LL(1) 分析法

对于LL(1) 文法，可以对其输入串进行**有效的无回溯自上而下**分析：

- 假设要用非终结符 A 进行匹配，面临的输入符号为 a，A 的所有产生式为：$$A \rightarrow \alpha_1 | \alpha_2 | ... | \alpha_n$$
  1. 若 $$a \in FIRST(\alpha_i)$$，则指派 $$\alpha_i$$ 执行匹配任务；
  2. 若 $$\forall i, a \notin FIRST(\alpha_i). \exist i, \epsilon \in FIRST(\alpha_i) 且 a \in FOLLOW(\alpha_i)$$，则让 A 与 $$\epsilon$$ 自动匹配。
  3. 否则，a 的出现是一种语法错误。

#### FIRST 和 FOLLOW 集

$$FISRT(\alpha) = \{a | \alpha \Rightarrow a..., a \in V_T\}$$

构造 $$FIRST(\alpha)$$：

1. 对于 $$\alpha = X, X \in V_T \cup V_N$$
   - 对于每一个 $$X \in V_T \cup V_N$$，连续使用下面规则，直至 FIRST 集合不再增大为止：
     1. 若 $$X \in V_T$$，则 $$FIRST(X) = \{X\}$$
     2. 若 $$X \in V_N, \exist X \rightarrow a..., a \in V_T$$，则 $$FIRST += \{a\}$$
     3. 若 $$ \exist X \rightarrow Y_1Y_2..Yi...Y_k $$
2. 

##  自下而上 Bottom-up

从输入串开始，逐步进行归约，直到文法的开始符号。

- 规约：根据文法的产生式规则，把串中出现的产生式右部替换成左部符号；

从树的叶节点开始，构造语法树。

算法：算符优先分析法，LR 分析法。

### 