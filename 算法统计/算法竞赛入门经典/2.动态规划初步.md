# 动态规划初步

## 问题：数字三角形

> 有一个由非负整数组成的三角形，第一行只有一个数字，出了最下面一行之外的每一个数字的左下方和右下方都有一个数字。
>
> 如果从第一行开始，每次可以向左下或右下走一格，怎样的走法能使路径节点和最大。

如果我们把每个格子按照行列编号，然后定义 `d(i, j)` 为从格子 `(i, j)` 出发时能得到的最大和，于是原问题即求解 `d(1, 1)`，可以得到状态转移方程：

- $d(i, j) = a(i, j) + max(d(i+1, j), d(i+1, j+1))$

最优子结构（optimal substructure）：全局最优解包含局部最优解，如果局部不是最优的，那么全局肯定不是最优的。

除了动态规划之外，这个问题还可以使用记忆化 (memoization) 的思想。

## DAG 上的动态规划

### 最长路径问题

> 嵌套矩形：有 n 个长宽分别为 $(a_i, b_i)$ 的矩形，如果对于两个矩形 X(a, b), Y(c, d)，如果 a<c, b<d 或者 a<d, b<c，那么我们称 X 可以被 Y 嵌套。
>
> 给定任意多的矩形，求最长的嵌套序列，使得序列中的每个矩形都能嵌套在后一个中。

这个问题中的“嵌套”就是一个典型的二元关系，可以 DAG 来建模。

在这样一个嵌套关系的 DAG 中，如果设 d(i) 表示从节点 i 出发的最长路长度，边的集合设为 E，那么可以得到有状态转移方程：

- $d(i) = max\{d(j) + 1 | (i, j) \in E\}$

假设 E 存储在邻接矩阵 G 中，如果我们得到了 G，那么可以用记忆化搜索解决 d 的值：

```c
int dp(int i)
{
  int& ans = d[i];
  if (ans > 0) return ans;
  for (int j = i; j <= n; j++) if (G[i][j]) ans >?= dp(j) + 1;
  return ans;
}
```

### 固定终点的最长最短路径

> 硬币问题：有 n 中硬币，面值分别为 $V_1, V_2, \cdots, V_n$，每种都有无限多。给定非负整数 S，可以选用多少个硬币使得面值只和为 S。
>
> 输出满足条件的策略中，硬币数量的最大值和最小值。

这个问题同样可以用 DAG 来建模，把每点看作“还需要凑足的面值”，对于还需要凑足 i 的面值设为 $r(i)$，则初始状态为 $r(S)$，目标状态为 $r(0)$。

注意到最大与最小是类似的，我们以最大值为例，伪代码如下：

```c
int dp(int S)
{
  int& ans = d[S];
  if (ans != -1) return ans;
  ans = -1 << 30;
  for (int i = 1; i <= n; i++) if (S >= V[i]) ans >?= dp(S-V[i])+1;
  return ans;
}
```

- 注意，用 `ans != -1` 而不是 `ans >= 0`，可以区分“无法到达”与“还没算过”这两种情况；

对于需要同时计算最大值的最小值的情况，使用递推而不是迭代更合适：

```c
min[0] = max[0] = 0;
for (int i = 1; i <= S; i++) 
{
  min[i] = INF; max[i] = -INF;
}
for (int i = 0; i <= S; i++)
	for (int j = 1; j <= n; j++)
    if (i >= V[j])
    {
      min[i] <?= min[i - V[j]] + 1;
      max[i] >?= max[i - V[j]] + 1;
    }
printf("%d %d\n", min[S], max[S]);
```

### 调试方式

对于上面的两个题目，可以用下面的方法打印字典序路径：

```c
void print_ans(int i)
{
  printf("%d ", i);
  for (int j = 1; j <= n; j++) if (G[i][j] && d[i] == d[j]+1)
  {
    print_ans(j);
    break;
  }
}
```

因为 d 的含义是“以 i 为起点的最长路径”，所以上面的方法打印字典序是可行的。另一打印字典序的方式就是在计算的过程中把路径记录下来。

区分“无法到达”与“还没算过”可以单独建立一个 `vis` 数组。

## 0-1 背包问题

### DAG 的状态

> 物品无限背包问题：有 n 中物品，每种均有无穷多个。第 i 种物品的体积为 $V_i$，重量为 $W_i$。选一些物品装到一个容器为 C 的背包中，使得在背包内物品的总体积不超过 C 的前提下，重量尽量的大。

跟硬币问题类似，这个问题可以用一个带权的 DAG 建模。

> 0-1 背包问题：有 n 种物品，每种只有一个。第 i 种物品的体积为 $V_i$，重量为 $W_i$。选一些物品装到一个容量为 C 的背包中，使得背包在物品的总体积不超过 C 的前提下尽量最大。

我们发现套用上面的模型已经不适用了。我们可以参考回溯法中，“阶段”的概念，把 n 种物品的选与不选的两种状态理解为一颗决策树的两个扩展过程。

于是如果我们可以用 `d(i, j)` 表示当前在第 i 层（即已经做了 i 次决策），剩余容量为 j 时接下来的重量和，那么可以得到状态转移方程：

- $d(i, j) = max\{d(i+1, j), d(i+1, j - V_i) + W_i\}$
- *PS*：上述公式即，每次决策的状态由下一次决策是否决定两种状态的最大值确定。

### 规划方向

对于 0-1 背包问题，我们容易得出一个对称的解法：

- $f(i, j) = max\{f(i-1, j), f(i - 1, j -V_i) + W_i\}$
- *PS*：跟上面的状态转移方程是完全对称的，决策树扩展方向恰好相反。

这个扩展方向的好处是：我们不需要多余的内存把 V 和 W 保存下来：

```c
for (int i = 0; i <= n; i++) {
  scanf("%d%d", &V, &W);
  for (int j = 0; j <= C; j++) {
    f[i][j] = (i == 1 ? 0 : f[i-1][j]);
    if (j >= V) f[i][j] >?= f[i-1][j-V] + W;
  }
}
```

### 滚动数组

f 可以降维成一维的。

## 方法总结

**状态转移方程是动态规划的核心。**

**除了要理解状态转移方程之外，在看题解时最好思考一下为什么要这么表示状态。**

动态规划通常存在两种规划方向。