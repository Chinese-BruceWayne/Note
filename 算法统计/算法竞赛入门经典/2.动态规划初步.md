# 动态规划初步

## 问题：数字三角形

> 有一个由非负整数组成的三角形，第一行只有一个数字，出了最下面一行之外的每一个数字的左下方和右下方都有一个数字。
>
> 如果从第一行开始，每次可以向左下或右下走一格，怎样的走法能使路径节点和最大。

如果我们把每个格子按照行列编号，然后定义 `d(i, j)` 为从格子 `(i, j)` 出发时能得到的最大和，于是原问题即求解 `d(1, 1)`，可以得到状态转移方程：

- $d(i, j) = a(i, j) + max(d(i+1, j), d(i+1, j+1))$

最优子结构（optimal substructure）：全局最优解包含局部最优解，如果局部不是最优的，那么全局肯定不是最优的。

除了动态规划之外，这个问题还可以使用记忆化 (memoization) 的思想。

## DAG 上的动态规划

### 最长路径问题

> 嵌套矩形：有 n 个长宽分别为 $(a_i, b_i)$ 的矩形，如果对于两个矩形 X(a, b), Y(c, d)，如果 a<c, b<d 或者 a<d, b<c，那么我们称 X 可以被 Y 嵌套。
>
> 给定任意多的矩形，求最长的嵌套序列，使得序列中的每个矩形都能嵌套在后一个中。

这个问题中的“嵌套”就是一个典型的二元关系，可以 DAG 来建模。

在这样一个嵌套关系的 DAG 中，如果设 d(i) 表示从节点 i 出发的最长路长度，边的集合设为 E，那么可以得到有状态转移方程：

- $d(i) = max\{d(j) + 1 | (i, j) \in E\}$

假设 E 存储在邻接矩阵 G 中，如果我们得到了 G，那么可以用记忆化搜索解决 d 的值：

```c
int dp(int i)
{
  int& ans = d[i];
  if (ans > 0) return ans;
  for (int j = i; j <= n; j++) if (G[i][j]) ans >?= dp(j) + 1;
  return ans;
}
```

### 固定终点的最长最短路径

> 硬币问题：有 n 中硬币，面值分别为 $V_1, V_2, \cdots, V_n$，每种都有无限多。给定非负整数 S，可以选用多少个硬币使得面值只和为 S。
>
> 输出满足条件的策略中，硬币数量的最大值和最小值。

这个问题同样可以用 DAG 来建模，把每点看作“还需要凑足的面值”，对于还需要凑足 i 的面值设为 $r(i)$，则初始状态为 $r(S)$，目标状态为 $r(0)$。

注意到最大与最小是类似的，我们以最大值为例，伪代码如下：

```c
int dp(int S)
{
  int& ans = d[S];
  if (ans != -1) return ans;
  ans = -1 << 30;
  for (int i = 1; i <= n; i++) if (S >= V[i]) ans >?= dp(S-V[i])+1;
  return ans;
}
```

- 注意，用 `ans != -1` 而不是 `ans >= 0`，可以区分“无法到达”与“还没算过”这两种情况；

对于需要同时计算最大值的最小值的情况，使用递推而不是迭代更合适：

```c
min[0] = max[0] = 0;
for (int i = 1; i <= S; i++) 
{
  min[i] = INF; max[i] = -INF;
}
for (int i = 0; i <= S; i++)
	for (int j = 1; j <= n; j++)
    if (i >= V[j])
    {
      min[i] <?= min[i - V[j]] + 1;
      max[i] >?= max[i - V[j]] + 1;
    }
printf("%d %d\n", min[S], max[S]);
```

### 调试方式

对于上面的两个题目，可以用下面的方法打印字典序路径：

```c
void print_ans(int i)
{
  printf("%d ", i);
  for (int j = 1; j <= n; j++) if (G[i][j] && d[i] == d[j]+1)
  {
    print_ans(j);
    break;
  }
}
```

因为 d 的含义是“以 i 为起点的最长路径”，所以上面的方法打印字典序是可行的。另一打印字典序的方式就是在计算的过程中把路径记录下来。

区分“无法到达”与“还没算过”可以单独建立一个 `vis` 数组。