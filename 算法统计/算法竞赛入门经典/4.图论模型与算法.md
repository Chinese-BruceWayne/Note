# 图论模型与算法

## 树

### 无根树转化为有根树

转化代码：

```c
void dfs(int u, int fa)
{
  int d = G[u].size();
  for (int i = 0; i < d; i++)
  {
    int v = G[u][i];
    if (v != fa) dfs(v, p[v] = u);
  }
}
```

### 表达式树

二叉树是表达式处理的常用工具，其中每个非叶子节点都表示一个运算符，它的左子树是这个运算符的第一个运算数，右子树则是这个运算符的第二个运算数。

如何通过一个字符串建立表达式树呢，方法有很多种（详见《编译原理》）。

### 最小生成树

在无向图中，连通且不含圈的图称为树。

如果给定无向图 G=(V,E)，如果存在一个 E 的子集连接了 V 中的所有点，那我们称这个子集为 G 的生成树，而权值最小的生成树则被称为最小生成树（Minimal Spanning Tree, MST）。

求一个 MST 的方法有很多种，最常见的有两种：Kruskal 算法和 Prim 算法，https://zhihu.com/question/27566032/answer/287968877

### 并查集

在上面的最小生成树问题中，有一个常见的图论问题要处理：

- 如何判断图中的两个点是否属于同一个“连通分量”（即一个连通图的所有点的集合）；
- 通过添加一个边的方法将两个“连通分量”合并。

上面这两个诉求有这样的特点：

- 我们只关心连通这一个信息，不关心具体的连通方式，类似于一个集合；

这个问题可以用一个树状结构“并查集”表示，并查集由多个集合构成，每个集合通过一颗树状的结构表示，两个节点如果属于同一个“连通分量”，那么它们一定属于同一棵树，这棵树的根节点被称为这个集合的“代表元”（representative）。

实现一个并查集核心在与 `find` 方法 ，即如何找到一个给定节点所在的树的代表元：

```c
int find(int x) {
  return p[x] == x ? x : p[x] = find(p[x]);
}
```

## 最短路问题

### Dijkstra 算法

之前动态规划的章节中有提到 DAG 中的动态规划可以用于解决最短路问题。但是如果图中有环，那么之前的方法就不适用了。

Dijkstra 算法可以用于计算正权图上的单源最短路问题（SSSP, Single-Source Shortest Paths）。用 `w[i][j]` 表示两个边之间的权值（INF 表示不连接），`d[i]` 表示源节点到节点 i 的距离，那么 Dijkstra 算法是实现如下：

```c
memset(v, 0, sizeof(v));
for (int i = 0; i < n; i++) d[i] = i == 0 ? 0 : INF;
for (int i = 0; i < n; i++)
{
  int x, m = INF;
  for (int y = 0; y < n; y++) if (!v[y] && d[y] <= m) m = d[x=y];
  v[x] = 1;
  for (int y = 0; y < n; y++) d[y] <?= d[x] + w[x][y];
}
```

简单地来说，Dijkstra 算法分为以下两步：

1. 在所以未访问的节点中，找出距离源节点最近的节点 x；
2. 给 x 做标记，并且更新所有与 x 响铃的点到源节点的距离；

### 优化 Dijkstra 算法

邻接表（Adjacency List）：一种稀疏图（Sparse Graph）的表示方式。在这种表示法中，每个结点 i 都有维护一个链表，里面保存着从 i 出发的所有边。

以下是一个从读入开始的例子：

```c
int n, m;
int first[MAXN];
int u[MAXM], v[MAXM], w[MAXM], next[MAXM];
void read_graph()
{
  scanf("%d%d", &n, &m);
  for (int i = 0; i < n; i++) first[i] = -1;
  for (int e = 0; e < m; e++) 
  {
    scanf("%d%d%d", &u[e], &v[e], &[e]);
    next[e] = first[u[e]];
    first[u[e]] = e;
  }
}
```

其中：

- `u`/`v`/`w` 都是原始输入，分别为编号为 e 的边连接的两个节点，以及这个边的权值；
- `first` 表示编号为 i 的节点的第一个边，用 `next` 连接所有的边；

使用邻接表可以优化 Dijkstra 算法的第二步，从 `O(n)` 优化到 `O(m)`。对于算法的第一步，即“找出未标号节点中的最小 d 值”，可以使用优先级队列进行优化。

使用优先级队列的代码实现如下：

```c
struct cmp {
  bool operator() (const int a, const int b) {
    return a % 10 > b % 10;
  }
}
priority_queue<int, vector<int>, cmp> q;
```

使用优先级队列可以把第一步的复杂度从 `O(n)` 降低到 `O(logn)`。