> 在实习过程中，在内部分享上学习的东西

# 客户端本地存储

## 作用

客户端本地存储主要有以下的几个作用：

1. 作为网络 IO 的缓存：缓存图片、缓存接口的 Response；
2. 保存配置或者数据：配置信息、状态信息、日志信息、Crash 信息等；
3. 作为内存的 Backing Store：暂存大文件、征用扩展内存；

## 常见存储方案分析

如何分析各种存储方案，主要考虑以下几个特性：

1. **读写性能**：平均读写性能、最坏读写性能；
2. **并发性能**：是否线程安全、读写操作互相并发的能力；
3. **数据完整性**：数据损失或丢失的概率；
4. **空间性能**：存储相同的数据，需要的磁盘与内存空间；

### Plist

plist 是一种 xml 格式，是 iOS 中最常用的配置存储数据格式，下面是一个例子：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>quiz</key>
	<dict>
		<key>question</key>
		<array>
			<dict>
				<key>text</key>
				<string>What does 'API' stand for?</string>
				<key>answer</key>
				<string>API stands for Application Programming Interface.</string>
			</dict>
			<dict>
				<key>text</key>
				<string>What's so good about pragmatic REST?</string>
				<key>answer</key>
				<string>It's focused on the api consumer, so it makes it easier for developers to contribute to your app library!</string>
			</dict>
		</array>
		
	</dict>
</dict>
```

- 读写性能都是 O(n)，必须全部从磁盘中读出写入；
- 数据完整性：每次都要全量读写。断电等不可抗力发生时，数据损失发生概率更大；
- 磁盘空间复杂度 O(n)，内存空间复杂度 0；
- 并发性能需要自己实现；

适用场景：

- Plist 不适合存储过多数据，这样会造成比较严重的读/写延时。同时也会增加 Plist 损坏的概率，导致数据丢失。
- Plist 适合与简单少量配置存储的场景，这种情况下，性能可以接受，操作的实现也足够简洁。

### NSUserDefault

`NSUserDefault` 是常用的客户端 K-V 存储方案，其底层使用 Plist 文件存储，不同于直接操作 Plist 文件读写数据：

- `NSUserDefault` 内部设置了**内存缓存**，大大提升了读性能；
- 通过异步跨线程的延时同步机制，`NSUserDefault` 会在写入事件发生后的一段时间批量的处理写入操作，提升写入性能。

性能分析：

- 读操作一般是直接读取内存，平均时间复杂度为 0；最坏读性能发生初始化之前，时间复杂度 O(n)；
- 如果平均 x 次写入进行一次全量写回，平均时间复杂度 O(n/x)；最坏就是连续全量写回 O(n)；
- 数据完整性：`NSUserDefault` 的异步延时同步机制很有可能导致数据在极端情况下无法触发，但是相对于 Plist，其有更少的回写次数。所以其数据损坏的可能性比 Plist 小，但是数据丢失的概率比 Plist 大。 
- 空间性能：除了内存开销，与 plist 一致；
- 并发性能：`NSUserDefault` 是线程安全的，但是不支持并发；

`NSUserDefault` 是 Plist 的优化：

- 有更好的读写性能、以及更友好简单的操作接口；
- 但是它需要额外的内存开销，而且写性能依然比较差，经常会触发全量回写，没有质的提升，依然只推荐存储较少的数据；
- 它规模可以比 Plist 大，4M 以内是比较推荐的值（超过4M，Console 会有 Warning）。
- 在性能提升的同时，也更容易导致数据丢失，不建议存储非常重要的配置数据

### MMKV

在了解 MMKV 技术之前我们需要先了解一下 `mmap` 技术：

- 技术痛点：在传统读写文件时，我们通常需要在内存中自己设置 buffer；以及处理文件与内存的同步（`seek`、`write`、`read`）。这通常比较复杂，我们还需要适当的 `fsync` 调用。

- 解决方案：Unix 操作系统提供了一个叫做 `mmap` 的函数，其底层适用 swap 实现。它将文件映射到进程的一块虚拟地址空间上，操作文件简化为直接操作内存。

- 示例程序：下面是一个拷贝文件的示例程序：

  ```c
  auto mmap_src = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd_src, 0);
  auto mmap_dst = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd_dst, 0);
  if (mmap_src == MAP_FAILED || mmap_dst == MAP_FAILED) {
      return ;
  }
  memcpy(mmap_dst, mmap_src, size);
  ```

- 因为这种方案使用了虚拟内存系统的 swap 机制，mmap 有以下特性：

  1. 并不占用进程内存：他是直接映射到操作系统对 IO 设备的缓存 PageCache 上。相对于正常IO操作，他直接就省去了PageCache 复制数据到进程中的 Buffer 这一步骤，省去了一大笔内存复制的开销。
  2. 数据共享：多个进程如果映射到同一文件，因为他们会映射到相同的物理内存上。一个典型的例子就是动态库加载，动态库就是通过 `mmap` 来实现共享的。
  3. 回写特性：手动 `msync` 触发；在 `munmap`、进程被杀死、内存紧张时自动触发；部分操作系统也会定期回写。只要数据写入了内存，即使写入进程被杀死，操作系统也会负责数据的回写。

- 注意这个技术的第三点，也就是说如果我们不关心回写磁盘的问题，操作系统也会自动完成。

什么是 MMKV（开源地址：https://github.com/Tencent/MMKV）？

- MMKV 是腾讯开源的一个 k-v 存储库，旨在替代 `NSUserDefault`；

- Plist 的写入瓶颈在于文件中没有数据结构，不能直接进行查询和数据插入操作，导致每次必须全量写入序列化后的数据；

- MMKV 技术使用 mmap 在内存中映射了一个简单的数据结构；这个数据结构大概是以下几个部分：

  | META_INFO                                 | KEY_SIZE | KEY_VALUE | DATA_SIZE | DATA_VALUE |
  | ----------------------------------------- | -------- | --------- | --------- | ---------- |
  | 一些基本信息<br/>比如检测数据完整性的 CRC | 键大小   | 键        | 值大小    | 值         |

MMKV 技术的工作流程：

- 读数据：MMKV 在初始化的时候会通过 mmap 读取所有的数据，然后在内存中生成一个 Dictionary。
- 写数据：当有一个新 pair 时，首先写入缓存，然后在 `mmap` 文件尾部追加一个 pair。
- 注意:warning:：MMKV 文件中对于一个 Key 可能有多个 Pair 存在。即使一直操作同一个Pair，也会导致MMKV文件的增大。当 MMKV 写入的数据将要超过相关文件的大小时，MMKV 会进行 `mumap` 操作，并扩大文件长度，重新进行 `mmap` 操作，同时用内存缓存中的数据全量写入，覆写原来的 MMKV 文件内容，在此时完成 key-value 一对多的数据去重，解决了 MMKV 文件占用过大的问题。

性能分析：

- 读性能：正常时直接读取内存，所以平均读性能时间复杂度为 0；初始化时需要全量读取到内存中，并且 MMKV 不覆盖的特性每个键有多个值对应。设每个键有 k 个存储记录，时间复杂度 k*O(n)；
- 写性能：通常的操作仍然在内存中进行，复杂度 0；最坏情况是触发了 swap，全量写回 O(n)；
- 空间性能：因为冗余记录的存在，空间复杂度 k*O(n)；内存空间复杂度 O(n)。
- 并发性能：线程安全，但是不支持并发；

### SQLite

### YYcache

### WCDB

